<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>拡張アクション: Grok Wars</title>
    <style>
        body { margin: 0; background: black; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #title {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); color: white; text-align: center;
            overflow-y: auto; padding: 10px; box-sizing: border-box;
            display: flex; flex-direction: column; align-items: center; z-index: 10;
        }
        #title h1 { font-size: 24px; margin: 10px 0; }
        #title p { font-size: 16px; margin: 5px 0; }
        .slider-container { width: 90%; margin: 8px 0; }
        .slider { width: 70%; vertical-align: middle; }
        .label { font-size: 14px; display: inline-block; width: 120px; text-align: left; }
        #startBtn {
            position: sticky; bottom: 10px; padding: 15px 30px; font-size: 18px;
            background: #00f; border: none; color: white; border-radius: 5px; cursor: pointer;
        }
        #startBtn:hover { background: #005; }
        #guide {
            position: absolute; top: 10px; left: 10px; color: white; font-size: 14px;
            background: rgba(0,0,0,0.5); padding: 8px; border-radius: 5px;
        }
        #title::-webkit-scrollbar { width: 10px; }
        #title::-webkit-scrollbar-thumb { background: #666; border-radius: 5px; }
        #title::-webkit-scrollbar-track { background: #333; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="title">
        <h1>拡張アクション: Grok Wars</h1>
        <p>操作: 左スライダーをドラッグで移動＆方向変更、自動で攻撃＆アイテム吸い寄せ</p>
        <div class="slider-container">
            <label class="label">難易度:</label>
            <input type="range" id="difficulty" min="1" max="5" value="3" class="slider">
            <span id="diffVal">3</span>
        </div>
        <div class="slider-container">
            <label class="label">移動速度:</label>
            <input type="range" id="playerSpeed" min="1" max="10" value="5" class="slider">
            <span id="speedVal">5</span>
        </div>
        <div class="slider-container">
            <label class="label">初期ライフ:</label>
            <input type="range" id="initialLife" min="3" max="10" value="5" class="slider">
            <span id="lifeVal">5</span>
        </div>
        <div class="slider-container">
            <label class="label">敵出現数:</label>
            <input type="range" id="enemySpawn" min="5" max="20" value="10" class="slider">
            <span id="spawnVal">10</span>
        </div>
        <div class="slider-container">
            <label class="label">アイテム耐久:</label>
            <input type="range" id="itemDur" min="10" max="50" value="20" class="slider">
            <span id="itemDurVal">20</span>
        </div>
        <div class="slider-container">
            <label class="label">敵耐久倍率:</label>
            <input type="range" id="enemyDurMul" min="0.5" max="2" step="0.1" value="1" class="slider">
            <span id="enemyDurVal">1</span>
        </div>
        <div class="slider-container">
            <label class="label">攻撃力:</label>
            <input type="range" id="attackPower" min="1" max="5" value="2" class="slider">
            <span id="atkVal">2</span>
        </div>
        <div class="slider-container">
            <label class="label">BGM音量:</label>
            <input type="range" id="bgmVol" min="0" max="1" step="0.1" value="0.5" class="slider">
            <span id="volVal">0.5</span>
        </div>
        <div class="slider-container">
            <label class="label">スコア倍率:</label>
            <input type="range" id="scoreMul" min="1" max="3" value="1" class="slider">
            <span id="scoreVal">1</span>
        </div>
        <div class="slider-container">
            <label class="label">操作感度:</label>
            <input type="range" id="joySens" min="0.5" max="2" step="0.1" value="1" class="slider">
            <span id="joyVal">1</span>
        </div>
        <div class="slider-container">
            <label class="label">敵速度倍率:</label>
            <input type="range" id="enemySpeedMul" min="0.5" max="2" step="0.1" value="0.5" class="slider">
            <span id="enemySpeedVal">0.5</span>
        </div>
        <button id="startBtn" onclick="startGame()">スタート</button>
    </div>
    <div id="guide" style="display: none;">左スライダー: 移動＆方向変更 / 自動攻撃＆アイテム吸い寄せ</div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            console.log(`Screen: ${width}x${height}`);
        }
        resize();
        window.addEventListener('resize', resize);

        let params = {};
        function updateSliderLabels() {
            document.getElementById('diffVal').textContent = document.getElementById('difficulty').value;
            document.getElementById('speedVal').textContent = document.getElementById('playerSpeed').value;
            document.getElementById('lifeVal').textContent = document.getElementById('initialLife').value;
            document.getElementById('spawnVal').textContent = document.getElementById('enemySpawn').value;
            document.getElementById('itemDurVal').textContent = document.getElementById('itemDur').value;
            document.getElementById('enemyDurVal').textContent = document.getElementById('enemyDurMul').value;
            document.getElementById('atkVal').textContent = document.getElementById('attackPower').value;
            document.getElementById('volVal').textContent = document.getElementById('bgmVol').value;
            document.getElementById('scoreVal').textContent = document.getElementById('scoreMul').value;
            document.getElementById('joyVal').textContent = document.getElementById('joySens').value;
            document.getElementById('enemySpeedVal').textContent = document.getElementById('enemySpeedMul').value;
        }
        updateSliderLabels();
        ['difficulty', 'playerSpeed', 'initialLife', 'enemySpawn', 'itemDur', 'enemyDurMul', 'attackPower', 'bgmVol', 'scoreMul', 'joySens', 'enemySpeedMul'].forEach(id => {
            document.getElementById(id).addEventListener('input', updateSliderLabels);
        });

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playBGM(vol) {
            const oscillator = audioCtx.createOscillator();
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
            const gainNode = audioCtx.createGain();
            gainNode.gain.value = vol;
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.start();
            return oscillator;
        }
        function playItemSound() {
            const oscillator = audioCtx.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
            const gainNode = audioCtx.createGain();
            gainNode.gain.setValueAtTime(params.bgmVol, audioCtx.currentTime);
            gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.2);
        }
        let bgm;

        let player, enemies = [], items = [], score = 0, gameOver = false, cleared = false;
        let moveTouch = { id: null, x: 0, y: 0, active: false };
        let wave = 0;

        class Entity {
            constructor(x, y, size, color, dur) {
                this.x = x; this.y = y; this.size = size; this.color = color; this.dur = dur; this.maxDur = dur; this.scale = 1;
                this.blink = 0;
            }
            updateScale() { this.scale = this.dur / this.maxDur; }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scale, this.scale);
                ctx.fillStyle = this.color;
                if (this.isItem) {
                    ctx.globalAlpha = 0.7 + 0.3 * Math.sin(this.blink);
                    this.blink += 0.1;
                }
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                if (this.type === 0 && !this.isItem) {
                    ctx.strokeStyle = 'yellow';
                    ctx.strokeRect(-this.size/2-2, -this.size/2-2, this.size+4, this.size+4);
                }
                ctx.globalAlpha = 1;
                ctx.restore();
            }
        }

        class Player extends Entity {
            constructor() {
                super(width/2, height/2, 30, 'blue', params.initialLife * 10);
                this.angle = 0; this.speed = params.playerSpeed;
                this.extensions = []; this.attack = params.attackPower;
            }
            update() {
                const dx = moveTouch.x - width/4, dy = moveTouch.y - (height-150);
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (moveTouch.active && dist > 20) {
                    this.x += (dx / dist) * this.speed * params.joySens;
                    this.y += (dy / dist) * this.speed * params.joySens;
                    this.angle = Math.atan2(dy, dx); // 即時回転
                }
                this.x = Math.max(0, Math.min(width, this.x));
                this.y = Math.max(0, Math.min(height, this.y));
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                let extX = this.size/2;
                this.extensions.forEach(ext => {
                    ctx.fillStyle = ext.color;
                    ctx.fillRect(extX, -ext.size/2, ext.size, ext.size);
                    extX += ext.size;
                });
                ctx.strokeStyle = 'red';
                ctx.beginPath();
                ctx.moveTo(this.size/2, 0);
                ctx.lineTo(this.size/2 + this.extensions.reduce((a, e) => a + e.size, 0) + 20, 0);
                ctx.stroke();
                ctx.restore();
            }
            attackEnemies() {
                const frontX = this.x + Math.cos(this.angle) * (this.size/2 + this.extensions.reduce((a, e) => a + e.size, 0));
                const frontY = this.y + Math.sin(this.angle) * (this.size/2 + this.extensions.reduce((a, e) => a + e.size, 0));
                enemies.forEach(e => {
                    const dist = Math.hypot(e.x - frontX, e.y - frontY);
                    if (dist < (e.size + this.size)/2) {
                        e.dur -= this.attack + this.extensions.length;
                        e.updateScale();
                        if (e.dur <= 0) {
                            enemies.splice(enemies.indexOf(e), 1);
                            score += 10 * params.scoreMul * (e.isBoss ? 10 : 1);
                            if ('vibrate' in navigator) navigator.vibrate(50);
                        }
                    }
                });
            }
            connectItem(item) {
                this.extensions.push(item);
                this.attack += 1;
                playItemSound();
                if ('vibrate' in navigator) navigator.vibrate(100);
            }
        }

        class Enemy extends Entity {
            constructor(x, y, size, color, dur, speed, type, isBoss = false) {
                super(x, y, size, color, dur * params.enemyDurMul);
                this.speed = speed * params.enemySpeedMul;
                this.type = type; this.isBoss = isBoss;
                this.zigzag = Math.random() * Math.PI * 2;
            }
            update() {
                const dx = player.x - this.x, dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);
                let moveX = (dx / dist) * this.speed;
                let moveY = (dy / dist) * this.speed;
                if (this.type === 0) {
                    this.zigzag += 0.1;
                    moveX += Math.sin(this.zigzag) * 0.5;
                }
                this.x += moveX;
                this.y += moveY;
                if (Math.hypot(this.x - player.x, this.y - player.y) < (this.size + player.size)/2) {
                    player.dur -= 5;
                    player.updateScale();
                    if (player.dur <= 0) gameOver = true;
                }
            }
        }

        class Item extends Entity {
            constructor(x, y) {
                super(x, y, 20, ['red', 'green', 'yellow'][Math.floor(Math.random()*3)], params.itemDur);
                this.isItem = true;
                this.baseSpeed = 1.5;
            }
            update() {
                const dx = player.x - this.x, dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);
                let speed = this.baseSpeed;
                if (dist < 100) speed = 5; // 100px以内で吸い寄せ
                if (dist > 1) {
                    this.x += (dx / dist) * speed;
                    this.y += (dy / dist) * speed;
                }
                if (dist < 50) { // 全方位で取得
                    player.connectItem(this);
                    items.splice(items.indexOf(this), 1);
                    console.log(`Item collected at (${this.x}, ${this.y})`);
                }
            }
        }

        function spawnEnemy() {
            const side = Math.random() * 4 | 0;
            let x, y;
            if (side === 0) { x = Math.random()*width; y = -50; }
            else if (side === 1) { x = Math.random()*width; y = height+50; }
            else if (side === 2) { x = -50; y = Math.random()*height; }
            else { x = width+50; y = Math.random()*height; }
            let type = Math.floor(Math.random()*3), size=30, dur=20, speed=1.5, color;
            if (type === 0) { color='orange'; speed=2; dur=10; }
            else if (type === 1) { color='purple'; dur=30; speed=1; }
            else { color='pink'; dur=15; speed=1.5; }
            enemies.push(new Enemy(x, y, size, color, dur, speed, type));
            console.log(`Spawned enemy: type=${type}, speed=${speed * params.enemySpeedMul}`);
        }

        function spawnMidBoss() {
            enemies.push(new Enemy(width/2, -100, 50, 'darkred', 50, 1.2, 0, true));
        }

        function spawnBoss() {
            enemies.push(new Enemy(width/2, -200, 80, 'black', 100, 0.8, 0, true));
        }

        function spawnItem() {
            const side = Math.random() * 4 | 0;
            let x, y;
            if (side === 0) { x = Math.random()*width; y = -50; }
            else if (side === 1) { x = Math.random()*width; y = height+50; }
            else if (side === 2) { x = -50; y = Math.random()*height; }
            else { x = width+50; y = Math.random()*height; }
            items.push(new Item(x, y));
            console.log(`Spawned item at (${x}, ${y})`);
        }

        function drawController() {
            ctx.save();
            ctx.translate(width/4, height-150);
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath(); ctx.arc(0, 0, 50, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.fillText('移動＆方向', -30, 60);
            if (moveTouch.active) {
                const dx = moveTouch.x - width/4, dy = moveTouch.y - (height-150);
                const dist = Math.min(50, Math.sqrt(dx*dx + dy*dy));
                const angle = Math.atan2(dy, dx);
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(Math.cos(angle)*dist, Math.sin(angle)*dist, 20, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.restore();
        }

        function startGame() {
            params = {
                difficulty: +document.getElementById('difficulty').value,
                playerSpeed: +document.getElementById('playerSpeed').value,
                initialLife: +document.getElementById('initialLife').value,
                enemySpawn: +document.getElementById('enemySpawn').value,
                itemDur: +document.getElementById('itemDur').value,
                enemyDurMul: +document.getElementById('enemyDurMul').value,
                attackPower: +document.getElementById('attackPower').value,
                bgmVol: +document.getElementById('bgmVol').value,
                scoreMul: +document.getElementById('scoreMul').value,
                joySens: +document.getElementById('joySens').value,
                enemySpeedMul: +document.getElementById('enemySpeedMul').value
            };
            document.getElementById('title').style.display = 'none';
            document.getElementById('guide').style.display = 'block';
            player = new Player();
            bgm = playBGM(params.bgmVol);
            spawnItem();
            gameLoop();
        }

        let lastTime = 0;
        function gameLoop(time) {
            if (gameOver || cleared) {
                bgm.stop();
                ctx.fillStyle = 'white';
                ctx.font = '40px Arial';
                ctx.fillText(gameOver ? 'Game Over' : 'Clear!', width/2 - 100, height/2);
                ctx.fillText(`Score: ${score}`, width/2 - 100, height/2 + 50);
                return;
            }
            requestAnimationFrame(gameLoop);
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = 'rgba(0,0,50,0.5)';
            ctx.fillRect(0,0,width,height);

            player.update();
            player.draw();
            player.attackEnemies();

            enemies.forEach(e => { e.update(); e.draw(); });
            items.forEach(i => { i.update(); i.draw(); });

            drawController();

            if (wave === 0 && enemies.length < params.enemySpawn) spawnEnemy();
            if (wave === 0 && enemies.length === 0 && Math.random() < 0.005 * params.difficulty) {
                wave = 1; spawnMidBoss();
            }
            if (wave === 1 && enemies.length === 0) {
                wave = 2; spawnBoss();
            }
            if (wave === 2 && enemies.length === 0) cleared = true;

            if (Math.random() < 0.015) spawnItem(); // アイテム出現率調整

            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText(`Life: ${Math.ceil(player.dur/10)}`, 10, 30);
            ctx.fillText(`Score: ${score}`, 10, 60);
        }

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const touches = e.changedTouches;
            for (let t of touches) {
                if (!moveTouch.active) {
                    moveTouch = { id: t.identifier, x: t.clientX, y: t.clientY, active: true };
                }
            }
        });
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const touches = e.changedTouches;
            for (let t of touches) {
                if (t.identifier === moveTouch.id) {
                    moveTouch.x = t.clientX;
                    moveTouch.y = t.clientY;
                }
            }
        });
        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            const touches = e.changedTouches;
            for (let t of touches) {
                if (t.identifier === moveTouch.id) moveTouch = { id: null, x: 0, y: 0, active: false };
            }
        });

        let mouseMove = false;
        canvas.addEventListener('mousedown', e => {
            moveTouch = { x: e.clientX, y: e.clientY, active: true };
            mouseMove = true;
        });
        canvas.addEventListener('mousemove', e => {
            if (mouseMove) moveTouch = { x: e.clientX, y: e.clientY, active: true };
        });
        canvas.addEventListener('mouseup', () => {
            moveTouch = { x: 0, y: 0, active: false };
            mouseMove = false;
        });
    </script>
</body>
</html>
