<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>拡張アクション: Grok Wars</title>
    <style>
        body { margin: 0; background: #1a1a2e; font-family: 'Arial', sans-serif; overflow: hidden; }
        canvas { display: block; }
        #title {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); color: #e5e5e5; text-align: center;
            overflow-y: auto; padding: 20px; box-sizing: border-box;
            display: flex; flex-direction: column; align-items: center; z-index: 10;
            border-radius: 15px; box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        #title h1 { font-size: 28px; color: #00d4ff; text-shadow: 0 0 10px #00d4ff; margin: 15px 0; }
        #title p { font-size: 18px; color: #b3e5fc; margin: 10px 0; }
        .slider-container { width: 90%; margin: 12px 0; }
        .slider { width: 70%; vertical-align: middle; accent-color: #00d4ff; }
        .label { font-size: 16px; color: #b3e5fc; display: inline-block; width: 140px; text-align: left; }
        #startBtn {
            position: sticky; bottom: 20px; padding: 18px 40px; font-size: 20px;
            background: linear-gradient(45deg, #00d4ff, #007bff); border: none; color: white;
            border-radius: 10px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;
        }
        #startBtn:hover {
            transform: scale(1.05); box-shadow: 0 0 15px #00d4ff;
        }
        #guide {
            position: absolute; top: 15px; left: 15px; color: #e5e5e5; font-size: 16px;
            background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }
        #title::-webkit-scrollbar { width: 12px; }
        #title::-webkit-scrollbar-thumb { background: #00d4ff; border-radius: 6px; }
        #title::-webkit-scrollbar-track { background: #2a2a3e; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="title">
        <h1>拡張アクション: Grok Wars</h1>
        <p>操作: 左スライダーをドラッグで移動＆方向変更、自動で攻撃＆アイテム吸い寄せ</p>
        <div class="slider-container">
            <label class="label">難易度:</label>
            <input type="range" id="difficulty" min="1" max="5" value="3" class="slider">
            <span id="diffVal">3</span>
        </div>
        <div class="slider-container">
            <label class="label">移動速度:</label>
            <input type="range" id="playerSpeed" min="1" max="10" value="2" class="slider">
            <span id="speedVal">2</span>
        </div>
        <div class="slider-container">
            <label class="label">初期ライフ:</label>
            <input type="range" id="initialLife" min="3" max="10" value="10" class="slider">
            <span id="lifeVal">10</span>
        </div>
        <div class="slider-container">
            <label class="label">敵出現数:</label>
            <input type="range" id="enemySpawn" min="5" max="20" value="10" class="slider">
            <span id="spawnVal">10</span>
        </div>
        <div class="slider-container">
            <label class="label">アイテム耐久:</label>
            <input type="range" id="itemDur" min="1" max="50" value="5" class="slider"> <!-- デフォルト5に変更 -->
            <span id="itemDurVal">5</span>
        </div>
        <div class="slider-container">
            <label class="label">敵耐久倍率:</label>
            <input type="range" id="enemyDurMul" min="0.5" max="2" step="0.1" value="1" class="slider">
            <span id="enemyDurVal">1</span>
        </div>
        <div class="slider-container">
            <label class="label">攻撃力:</label>
            <input type="range" id="attackPower" min="1" max="5" value="2" class="slider">
            <span id="atkVal">2</span>
        </div>
        <div class="slider-container">
            <label class="label">BGM音量:</label>
            <input type="range" id="bgmVol" min="0" max="1" step="0.1" value="0.5" class="slider">
            <span id="volVal">0.5</span>
        </div>
        <div class="slider-container">
            <label class="label">スコア倍率:</label>
            <input type="range" id="scoreMul" min="1" max="3" value="1" class="slider">
            <span id="scoreVal">1</span>
        </div>
        <div class="slider-container">
            <label class="label">操作感度:</label>
            <input type="range" id="joySens" min="0.5" max="2" step="0.1" value="1" class="slider">
            <span id="joyVal">1</span>
        </div>
        <div class="slider-container">
            <label class="label">敵速度倍率:</label>
            <input type="range" id="enemySpeedMul" min="0.5" max="2" step="0.1" value="0.5" class="slider">
            <span id="enemySpeedVal">0.5</span>
        </div>
        <div class="slider-container">
            <label class="label">ボス耐久倍率:</label>
            <input type="range" id="bossDurMul" min="0.5" max="2" step="0.1" value="0.5" class="slider">
            <span id="bossDurVal">0.5</span>
        </div>
        <div class="slider-container">
            <label class="label">ノックバック強度:</label>
            <input type="range" id="knockbackMul" min="0.5" max="3" step="0.1" value="1" class="slider">
            <span id="knockbackVal">1</span>
        </div>
        <button id="startBtn">スタート</button>
    </div>
    <div id="guide" style="display: none;">左スライダー: 移動＆方向変更 / 自動攻撃＆アイテム吸い寄せ</div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            console.log(`Screen resized: ${width}x${height}`);
        }
        resize();
        window.addEventListener('resize', resize);

        let params = {};
        function updateSliderLabels() {
            document.getElementById('diffVal').textContent = document.getElementById('difficulty').value;
            document.getElementById('speedVal').textContent = document.getElementById('playerSpeed').value;
            document.getElementById('lifeVal').textContent = document.getElementById('initialLife').value;
            document.getElementById('spawnVal').textContent = document.getElementById('enemySpawn').value;
            document.getElementById('itemDurVal').textContent = document.getElementById('itemDur').value;
            document.getElementById('enemyDurVal').textContent = document.getElementById('enemyDurMul').value;
            document.getElementById('atkVal').textContent = document.getElementById('attackPower').value;
            document.getElementById('volVal').textContent = document.getElementById('bgmVol').value;
            document.getElementById('scoreVal').textContent = document.getElementById('scoreMul').value;
            document.getElementById('joyVal').textContent = document.getElementById('joySens').value;
            document.getElementById('enemySpeedVal').textContent = document.getElementById('enemySpeedMul').value;
            document.getElementById('bossDurVal').textContent = document.getElementById('bossDurMul').value;
            document.getElementById('knockbackVal').textContent = document.getElementById('knockbackMul').value;
        }
        updateSliderLabels();
        ['difficulty', 'playerSpeed', 'initialLife', 'enemySpawn', 'itemDur', 'enemyDurMul', 'attackPower', 'bgmVol', 'scoreMul', 'joySens', 'enemySpeedMul', 'bossDurMul', 'knockbackMul'].forEach(id => {
            document.getElementById(id).addEventListener('input', updateSliderLabels);
        });

        let audioCtx;
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            console.log('AudioContext initialized');
        } catch (e) {
            console.error('AudioContext initialization failed:', e);
        }
        function playBGM(vol) {
            if (!audioCtx) return null;
            try {
                const oscillator = audioCtx.createOscillator();
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                const gainNode = audioCtx.createGain();
                gainNode.gain.value = vol;
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.start();
                console.log('BGM started with volume:', vol);
                return oscillator;
            } catch (e) {
                console.error('BGM play failed:', e);
                return null;
            }
        }
        function playItemSound() {
            if (!audioCtx) return;
            try {
                const oscillator = audioCtx.createOscillator();
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
                const gainNode = audioCtx.createGain();
                gainNode.gain.setValueAtTime(params.bgmVol, audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.2);
                console.log('Item sound played');
            } catch (e) {
                console.error('Item sound play failed:', e);
            }
        }
        let bgm;

        let player, enemies = [], items = [], score = 0, gameOver = false, cleared = false;
        let moveTouch = { id: null, x: 0, y: 0, active: false };
        let wave = 0;
        let grassOffset = 0;

        class Entity {
            constructor(x, y, size, color, dur) {
                this.x = x; this.y = y; this.size = size; this.color = color; this.dur = dur; this.maxDur = dur; this.scale = 1;
                this.blink = 0;
                this.baseColor = color;
            }
            updateScale() {
                this.scale = this.dur / this.maxDur;
                const alpha = Math.floor(this.scale * 255).toString(16).padStart(2, '0');
                this.color = this.baseColor + alpha;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scale, this.scale);
                let gradient;
                if (this.isItem) {
                    gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size/2);
                    gradient.addColorStop(0, this.color.replace(/ff$/, 'ff'));
                    gradient.addColorStop(1, this.color.replace(/ff$/, '33'));
                    ctx.globalAlpha = 0.8 + 0.2 * Math.sin(this.blink);
                    this.blink += 0.1;
                } else {
                    gradient = ctx.createLinearGradient(-this.size/2, -this.size/2, this.size/2, this.size/2);
                    gradient.addColorStop(0, this.color.replace(/ff$/, 'cc'));
                    gradient.addColorStop(1, this.color.replace(/ff$/, '66'));
                }
                ctx.fillStyle = gradient;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color.replace(/ff$/, '33');
                ctx.beginPath();
                ctx.arc(0, 0, this.size/2, 0, Math.PI * 2);
                ctx.fill();
                if (this.type === 0 && !this.isItem) {
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
                ctx.restore();
            }
        }

        class Player extends Entity {
            constructor() {
                super(width/2, height/2, 30, '#ff4500', params.initialLife * 10);
                this.angle = 0; this.speed = params.playerSpeed;
                this.extensions = []; this.attack = params.attackPower;
                this.courage = 0;
            }
            update() {
                const dx = moveTouch.x - width/4, dy = moveTouch.y - (height-150);
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (moveTouch.active && dist > 20) {
                    this.x += (dx / dist) * this.speed * params.joySens;
                    this.y += (dy / dist) * this.speed * params.joySens;
                    this.angle = Math.atan2(dy, dx);
                    this.courage = (this.courage + 0.1) % (Math.PI * 2);
                }
                this.x = Math.max(0, Math.min(width, this.x));
                this.y = Math.max(0, Math.min(height, this.y));
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                let gradient = ctx.createLinearGradient(-this.size/2, -this.size/2, this.size/2, this.size/2);
                gradient.addColorStop(0, '#ff4500cc');
                gradient.addColorStop(1, '#ff8c00cc');
                ctx.fillStyle = gradient;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ff450066';
                ctx.beginPath();
                ctx.arc(0, 0, this.size/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(this.size/2, 0);
                ctx.lineTo(this.size/2 + 20, 0);
                ctx.stroke();
                let extX = this.size/2 + 20;
                this.extensions.forEach(ext => {
                    ctx.save();
                    ctx.translate(extX, 0);
                    let extGradient = ctx.createLinearGradient(-ext.size/2, -ext.size/2, ext.size/2, ext.size/2);
                    extGradient.addColorStop(0, ext.color.replace(/ff$/, 'cc'));
                    extGradient.addColorStop(1, ext.color.replace(/ff$/, '44'));
                    ctx.fillStyle = extGradient;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = ext.color.replace(/ff$/, '33');
                    ctx.beginPath();
                    ctx.arc(0, 0, ext.size/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    extX += ext.size;
                });
                ctx.shadowBlur = 0;
                ctx.restore();
            }
            attackEnemies() {
                const baseX = this.x + Math.cos(this.angle) * (this.size/2 + 20);
                const baseY = this.y + Math.sin(this.angle) * (this.size/2 + 20);
                enemies.forEach(e => {
                    const dist = Math.hypot(e.x - baseX, e.y - baseY);
                    if (dist < (e.size + this.size)/2) {
                        e.dur -= this.attack;
                        e.updateScale();
                        const kbDist = (e.isBoss ? 10 : 20) * params.knockbackMul;
                        const kbDx = (e.x - baseX) / dist * kbDist;
                        const kbDy = (e.y - baseY) / dist * kbDist;
                        e.x += kbDx;
                        e.y += kbDy;
                        console.log('Knockback applied to enemy from player');
                        if (e.dur <= 0) {
                            enemies.splice(enemies.indexOf(e), 1);
                            score += 10 * params.scoreMul * (e.isBoss ? 10 : 1);
                            if ('vibrate' in navigator) navigator.vibrate(50);
                        }
                    }
                });

                let extX = this.size/2 + 20;
                this.extensions.forEach(ext => {
                    const extCenterX = this.x + Math.cos(this.angle) * extX + Math.cos(this.angle + Math.PI/2) * (ext.size/2);
                    const extCenterY = this.y + Math.sin(this.angle) * extX + Math.sin(this.angle + Math.PI/2) * (ext.size/2);
                    enemies.forEach(e => {
                        const dist = Math.hypot(e.x - extCenterX, e.y - extCenterY);
                        if (dist < (e.size + ext.size)/2) {
                            const damage = this.attack / (this.extensions.length + 1);
                            e.dur -= damage;
                            e.updateScale();
                            const kbDist = (e.isBoss ? 10 : 20) * params.knockbackMul;
                            const kbDx = (e.x - extCenterX) / dist * kbDist;
                            const kbDy = (e.y - extCenterY) / dist * kbDist;
                            e.x += kbDx;
                            e.y += kbDy;
                            console.log('Knockback applied to enemy from extension');
                            if (e.dur <= 0) {
                                enemies.splice(enemies.indexOf(e), 1);
                                score += 10 * params.scoreMul * (e.isBoss ? 10 : 1);
                                if ('vibrate' in navigator) navigator.vibrate(50);
                            }
                        }
                    });
                    extX += ext.size;
                });
            }
            connectItem(item) {
                this.extensions.push(item);
                this.attack += 1;
                playItemSound();
                if ('vibrate' in navigator) navigator.vibrate(100);
            }
        }

        class Enemy extends Entity {
            constructor(x, y, size, color, dur, speed, type, isBoss = false) {
                super(x, y, size, color, dur);
                this.speed = speed * params.enemySpeedMul;
                this.type = type; this.isBoss = isBoss;
                this.zigzag = Math.random() * Math.PI * 2;
                this.cunning = Math.random() * 2 * Math.PI;
            }
            update() {
                const dx = player.x - this.x, dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);
                let moveX = (dx / dist) * this.speed;
                let moveY = (dy / dist) * this.speed;
                if (this.type === 0) {
                    this.zigzag += 0.1;
                    moveX += Math.sin(this.zigzag) * 0.5;
                }
                this.cunning += 0.05;
                moveX += Math.cos(this.cunning) * 0.3;
                moveY += Math.sin(this.cunning) * 0.3;
                this.x += moveX;
                this.y += moveY;
                if (Math.hypot(this.x - player.x, this.y - player.y) < (this.size + player.size)/2) {
                    player.dur -= 5;
                    player.updateScale();
                    if (player.dur <= 0) gameOver = true;
                    const kbDist = (this.isBoss ? 10 : 20) * params.knockbackMul;
                    const kbDx = (this.x - player.x) / dist * kbDist;
                    const kbDy = (this.y - player.y) / dist * kbDist;
                    this.x += kbDx;
                    this.y += kbDy;
                    console.log('Enemy knocked back on player collision');
                }
                items.forEach(i => {
                    const iDist = Math.hypot(this.x - i.x, this.y - i.y);
                    if (iDist < (this.size + i.size)/2) {
                        const kbDist = (this.isBoss ? 10 : 20) * params.knockbackMul;
                        const kbDx = (this.x - i.x) / iDist * kbDist;
                        const kbDy = (this.y - i.y) / iDist * kbDist;
                        this.x += kbDx;
                        this.y += kbDy;
                        console.log('Enemy knocked back on item collision');
                    }
                });
            }
        }

        class Item extends Entity {
            constructor(x, y) {
                super(x, y, 20, ['#00ff00', '#ff00ff', '#ffff00'][Math.floor(Math.random()*3)], params.itemDur);
                this.isItem = true;
                this.baseSpeed = 1.0;
                this.healAura = 0;
            }
            update() {
                const dx = player.x - this.x, dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);
                let speed = this.baseSpeed;
                if (dist < 150) speed = 8;
                if (dist > 1) {
                    this.x += (dx / dist) * speed;
                    this.y += (dy / dist) * speed;
                }
                this.healAura = (this.healAura + 0.15) % (Math.PI * 2);
                if (dist < 50) {
                    player.connectItem(this);
                    items.splice(items.indexOf(this), 1);
                    console.log(`Item collected at (${this.x}, ${this.y})`);
                }
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                let gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size/2);
                gradient.addColorStop(0, this.color.replace(/ff$/, 'ff'));
                gradient.addColorStop(1, this.color.replace(/ff$/, '33'));
                ctx.fillStyle = gradient;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color.replace(/ff$/, '33');
                ctx.beginPath();
                ctx.arc(0, 0, this.size/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(0, 0, this.size/2 + 5 * Math.sin(this.healAura), 0, Math.PI * 2);
                ctx.strokeStyle = this.color.replace(/ff$/, '66');
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
                ctx.restore();
            }
        }

        function spawnEnemy() {
            const side = Math.random() * 4 | 0;
            let x, y;
            if (side === 0) { x = Math.random()*width; y = -50; }
            else if (side === 1) { x = Math.random()*width; y = height+50; }
            else if (side === 2) { x = -50; y = Math.random()*height; }
            else { x = width+50; y = Math.random()*height; }
            let type = Math.floor(Math.random()*3), size=30, dur=20, speed=1.5, color;
            if (type === 0) { color='#ffa500'; speed=2; dur=10; }
            else if (type === 1) { color='#800080'; dur=30; speed=1; }
            else { color='#ffc0cb'; dur=15; speed=1.5; }
            enemies.push(new Enemy(x, y, size, color, dur * params.enemyDurMul, speed, type));
            console.log(`Spawned enemy: type=${type}, speed=${speed * params.enemySpeedMul}`);
        }

        function spawnMidBoss() {
            enemies.push(new Enemy(width/2, -100, 50, '#8b0000', 50 * params.bossDurMul, 1.2, 0, true));
        }

        function spawnBoss() {
            enemies.push(new Enemy(width/2, -200, 80, '#000000', 100 * params.bossDurMul, 0.8, 0, true));
        }

        function spawnItem() {
            const side = Math.random() * 4 | 0;
            let x, y;
            if (side === 0) { x = Math.random()*width; y = -50; }
            else if (side === 1) { x = Math.random()*width; y = height+50; }
            else if (side === 2) { x = -50; y = Math.random()*height; }
            else { x = width+50; y = Math.random()*height; }
            items.push(new Item(x, y));
            console.log(`Spawned item at (${x}, ${y})`);
        }

        function drawController() {
            ctx.save();
            ctx.translate(width/4, height-150);
            let gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 50);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(0, 212, 255, 0.1)');
            ctx.fillStyle = gradient;
            ctx.beginPath(); ctx.arc(0, 0, 50, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#e5e5e5';
            ctx.font = '14px Arial';
            ctx.fillText('移動＆方向', -35, 70);
            if (moveTouch.active) {
                const dx = moveTouch.x - width/4, dy = moveTouch.y - (height-150);
                const dist = Math.min(50, Math.sqrt(dx*dx + dy*dy));
                const angle = Math.atan2(dy, dx);
                ctx.fillStyle = '#00d4ff';
                ctx.beginPath();
                ctx.arc(Math.cos(angle)*dist, Math.sin(angle)*dist, 20, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawGrass() {
            ctx.save();
            let grassGradient = ctx.createLinearGradient(0, height-50, 0, height);
            grassGradient.addColorStop(0, '#2e7d32');
            grassGradient.addColorStop(1, '#1b5e20');
            ctx.fillStyle = grassGradient;
            ctx.fillRect(0, height-50, width, 50);
            ctx.fillStyle = '#276f2e';
            for (let x = 0; x < width; x += 10) {
                ctx.beginPath();
                ctx.moveTo(x, height-50);
                ctx.quadraticCurveTo(x + 5 + 5 * Math.sin(grassOffset + x/20), height-70, x + 10, height-50);
                ctx.stroke();
            }
            grassOffset += 0.05;
            ctx.restore();
        }

        function startGame() {
            console.log('startGame called');
            try {
                params = {
                    difficulty: +document.getElementById('difficulty').value,
                    playerSpeed: +document.getElementById('playerSpeed').value,
                    initialLife: +document.getElementById('initialLife').value,
                    enemySpawn: +document.getElementById('enemySpawn').value,
                    itemDur: +document.getElementById('itemDur').value,
                    enemyDurMul: +document.getElementById('enemyDurMul').value,
                    attackPower: +document.getElementById('attackPower').value,
                    bgmVol: +document.getElementById('bgmVol').value,
                    scoreMul: +document.getElementById('scoreMul').value,
                    joySens: +document.getElementById('joySens').value,
                    enemySpeedMul: +document.getElementById('enemySpeedMul').value,
                    bossDurMul: +document.getElementById('bossDurMul').value,
                    knockbackMul: +document.getElementById('knockbackMul').value
                };
                console.log('Parameters loaded:', params);
                document.getElementById('title').style.display = 'none';
                document.getElementById('guide').style.display = 'block';
                player = new Player();
                console.log('Player initialized');
                bgm = playBGM(params.bgmVol);
                // 初期10個のアイテムをスポーン
                for (let i = 0; i < 10; i++) spawnItem();
                console.log('Initial 10 items spawned');
                gameLoop();
            } catch (e) {
                console.error('startGame failed:', e);
            }
        }

        let lastTime = 0;
        function gameLoop(time) {
            if (gameOver || cleared) {
                if (bgm) bgm.stop();
                ctx.fillStyle = 'white';
                ctx.font = '40px Arial';
                ctx.fillText(gameOver ? 'Game Over' : 'Clear!', width/2 - 100, height/2);
                ctx.fillText(`Score: ${score}`, width/2 - 100, height/2 + 50);
                return;
            }
            requestAnimationFrame(gameLoop);
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            ctx.clearRect(0, 0, width, height);
            let bgGradient = ctx.createLinearGradient(0, 0, 0, height);
            bgGradient.addColorStop(0, '#a5d6a7');
            bgGradient.addColorStop(1, '#81c784');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, width, height);
            drawGrass();

            player.update();
            player.draw();
            player.attackEnemies();

            enemies.forEach(e => { e.update(); e.draw(); });
            items.forEach(i => { i.update(); i.draw(); });

            drawController();

            if (wave === 0 && enemies.length < params.enemySpawn) spawnEnemy();
            if (wave === 0 && enemies.length === 0) {
                wave = 1;
                spawnMidBoss();
                console.log('Mid boss spawned');
            }
            if (wave === 1 && enemies.length === 0) {
                wave = 2;
                spawnBoss();
                console.log('Boss spawned');
            }
            if (wave === 2 && enemies.length === 0) cleared = true;

            if (items.length < 10 && Math.random() < 0.015) spawnItem(); // アイテム数を10に維持

            ctx.fillStyle = '#e5e5e5';
            ctx.font = '22px Arial';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#00d4ff';
            ctx.fillText(`Life: ${Math.ceil(player.dur/10)}`, 15, 40);
            ctx.fillText(`Score: ${score}`, 15, 70);
            ctx.shadowBlur = 0;
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            console.log('Start button clicked');
            startGame();
        });

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const touches = e.changedTouches;
            for (let t of touches) {
                if (!moveTouch.active) {
                    moveTouch = { id: t.identifier, x: t.clientX, y: t.clientY, active: true };
                }
            }
        });
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const touches = e.changedTouches;
            for (let t of touches) {
                if (t.identifier === moveTouch.id) {
                    moveTouch.x = t.clientX;
                    moveTouch.y = t.clientY;
                }
            }
        });
        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            const touches = e.changedTouches;
            for (let t of touches) {
                if (t.identifier === moveTouch.id) moveTouch = { id: null, x: 0, y: 0, active: false };
            }
        });

        let mouseMove = false;
        canvas.addEventListener('mousedown', e => {
            moveTouch = { x: e.clientX, y: e.clientY, active: true };
            mouseMove = true;
        });
        canvas.addEventListener('mousemove', e => {
            if (mouseMove) moveTouch = { x: e.clientX, y: e.clientY, active: true };
        });
        canvas.addEventListener('mouseup', () => {
            moveTouch = { x: 0, y: 0, active: false };
            mouseMove = false;
        });

        window.addEventListener('error', e => {
            console.error('Global error:', e.message, 'at', e.filename, e.lineno);
        });
    </script>
</body>
</html>
