<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>拡張アクション: Grok Wars</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
        #title { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); color: white; text-align: center; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; }
        #title button { padding: 10px 20px; font-size: 20px; }
        .slider { width: 80%; margin: 10px; }
        .label { font-size: 18px; }
        #guide { position: absolute; top: 10px; left: 10px; color: white; font-size: 16px; background: rgba(0,0,0,0.5); padding: 10px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="title">
        <h1>拡張アクション: Grok Wars</h1>
        <p>操作: 左半分をドラッグで移動、右半分をドラッグで回転・攻撃</p>
        <div>
            <label class="label">難易度: <input type="range" id="difficulty" min="1" max="5" value="3" class="slider"><span id="diffVal">3</span></label>
        </div>
        <div>
            <label class="label">プレイヤースピード: <input type="range" id="playerSpeed" min="1" max="10" value="5" class="slider"><span id="speedVal">5</span></label>
        </div>
        <div>
            <label class="label">初期ライフ: <input type="range" id="initialLife" min="3" max="10" value="5" class="slider"><span id="lifeVal">5</span></label>
        </div>
        <div>
            <label class="label">敵出現数: <input type="range" id="enemySpawn" min="5" max="20" value="10" class="slider"><span id="spawnVal">10</span></label>
        </div>
        <div>
            <label class="label">アイテム耐久: <input type="range" id="itemDur" min="10" max="50" value="20" class="slider"><span id="itemDurVal">20</span></label>
        </div>
        <div>
            <label class="label">敵耐久倍率: <input type="range" id="enemyDurMul" min="0.5" max="2" step="0.1" value="1" class="slider"><span id="enemyDurVal">1</span></label>
        </div>
        <div>
            <label class="label">回転速度: <input type="range" id="rotSpeed" min="1" max="10" value="5" class="slider"><span id="rotVal">5</span></label>
        </div>
        <div>
            <label class="label">攻撃力: <input type="range" id="attackPower" min="1" max="5" value="2" class="slider"><span id="atkVal">2</span></label>
        </div>
        <div>
            <label class="label">BGMボリューム: <input type="range" id="bgmVol" min="0" max="1" step="0.1" value="0.5" class="slider"><span id="volVal">0.5</span></label>
        </div>
        <div>
            <label class="label">スコア倍率: <input type="range" id="scoreMul" min="1" max="3" value="1" class="slider"><span id="scoreVal">1</span></label>
        </div>
        <div>
            <label class="label">ジョイスティック感度: <input type="range" id="joySens" min="0.5" max="2" step="0.1" value="1" class="slider"><span id="joyVal">1</span></label>
        </div>
        <button onclick="startGame()">スタート</button>
    </div>
    <div id="guide" style="display: none;">左:移動 / 右:回転・攻撃</div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        resize();
        window.addEventListener('resize', resize);

        // パラメーター変数
        let params = {};
        function updateSliderLabels() {
            document.getElementById('diffVal').textContent = document.getElementById('difficulty').value;
            document.getElementById('speedVal').textContent = document.getElementById('playerSpeed').value;
            document.getElementById('lifeVal').textContent = document.getElementById('initialLife').value;
            document.getElementById('spawnVal').textContent = document.getElementById('enemySpawn').value;
            document.getElementById('itemDurVal').textContent = document.getElementById('itemDur').value;
            document.getElementById('enemyDurVal').textContent = document.getElementById('enemyDurMul').value;
            document.getElementById('rotVal').textContent = document.getElementById('rotSpeed').value;
            document.getElementById('atkVal').textContent = document.getElementById('attackPower').value;
            document.getElementById('volVal').textContent = document.getElementById('bgmVol').value;
            document.getElementById('scoreVal').textContent = document.getElementById('scoreMul').value;
            document.getElementById('joyVal').textContent = document.getElementById('joySens').value;
        }
        updateSliderLabels();
        ['difficulty', 'playerSpeed', 'initialLife', 'enemySpawn', 'itemDur', 'enemyDurMul', 'rotSpeed', 'attackPower', 'bgmVol', 'scoreMul', 'joySens'].forEach(id => {
            document.getElementById(id).addEventListener('input', updateSliderLabels);
        });

        // BGM
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playBGM(vol) {
            const oscillator = audioCtx.createOscillator();
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
            const gainNode = audioCtx.createGain();
            gainNode.gain.value = vol;
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.start();
            return oscillator;
        }
        let bgm;

        // ゲーム変数
        let player, enemies = [], items = [], score = 0, gameOver = false, cleared = false;
        let moveTouch = { id: null, x: 0, y: 0, active: false };
        let rotTouch = { id: null, x: 0, y: 0, active: false };
        let wave = 0;

        class Entity {
            constructor(x, y, size, color, dur) {
                this.x = x; this.y = y; this.size = size; this.color = color; this.dur = dur; this.maxDur = dur; this.scale = 1;
            }
            updateScale() { this.scale = this.dur / this.maxDur; }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scale, this.scale);
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.restore();
            }
        }

        class Player extends Entity {
            constructor() {
                super(width/2, height/2, 30, 'blue', params.initialLife * 10);
                this.angle = 0; this.speed = params.playerSpeed; this.rotSpeed = params.rotSpeed * Math.PI / 180;
                this.extensions = []; this.attack = params.attackPower;
            }
            update() {
                // 移動
                const dx = moveTouch.x - width/4, dy = moveTouch.y - (height-150);
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (moveTouch.active && dist > 20) {
                    this.x += (dx / dist) * this.speed * params.joySens;
                    this.y += (dy / dist) * this.speed * params.joySens;
                }
                // 回転
                const rx = rotTouch.x - (width * 3/4), ry = rotTouch.y - (height-150);
                const rdist = Math.sqrt(rx*rx + ry*ry);
                if (rotTouch.active && rdist > 20) {
                    this.angle += (Math.atan2(ry, rx) - this.angle) * 0.1 * this.rotSpeed;
                }
                this.x = Math.max(0, Math.min(width, this.x));
                this.y = Math.max(0, Math.min(height, this.y));
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                let extX = this.size/2;
                this.extensions.forEach(ext => {
                    ctx.fillStyle = ext.color;
                    ctx.fillRect(extX, -ext.size/2, ext.size, ext.size);
                    extX += ext.size;
                });
                ctx.restore();
            }
            attackEnemies() {
                const frontX = this.x + Math.cos(this.angle) * (this.size/2 + this.extensions.reduce((a, e) => a + e.size, 0));
                const frontY = this.y + Math.sin(this.angle) * (this.size/2 + this.extensions.reduce((a, e) => a + e.size, 0));
                enemies.forEach(e => {
                    const dist = Math.hypot(e.x - frontX, e.y - frontY);
                    if (dist < (e.size + this.size)/2 && rotTouch.active) {
                        e.dur -= this.attack + this.extensions.length;
                        e.updateScale();
                        if (e.dur <= 0) {
                            enemies.splice(enemies.indexOf(e), 1);
                            score += 10 * params.scoreMul * (e.isBoss ? 10 : 1);
                            if ('vibrate' in navigator) navigator.vibrate(50); // 振動
                        }
                    }
                });
            }
            connectItem(item) {
                this.extensions.push(item);
                this.attack += 1;
            }
        }

        class Enemy extends Entity {
            constructor(x, y, size, color, dur, speed, type, isBoss = false) {
                super(x, y, size, color, dur * params.enemyDurMul);
                this.speed = speed; this.type = type; this.isBoss = isBoss;
            }
            update() {
                const dx = player.x - this.x, dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
                if (Math.hypot(this.x - player.x, this.y - player.y) < (this.size + player.size)/2) {
                    player.dur -= 5;
                    player.updateScale();
                    if (player.dur <= 0) gameOver = true;
                }
            }
        }

        class Item extends Entity {
            constructor(x, y) {
                super(x, y, 20, ['red', 'green', 'yellow'][Math.floor(Math.random()*3)], params.itemDur);
            }
            update() {
                if (Math.hypot(this.x - player.x, this.y - player.y) < (this.size + player.size)/2 && 
                    Math.abs(Math.atan2(this.y - player.y, this.x - player.x) - player.angle) < Math.PI/4) {
                    player.connectItem(this);
                    items.splice(items.indexOf(this), 1);
                }
            }
        }

        function spawnEnemy() {
            const side = Math.random() * 4 | 0;
            let x, y;
            if (side === 0) { x = Math.random()*width; y = -50; }
            else if (side === 1) { x = Math.random()*width; y = height+50; }
            else if (side === 2) { x = -50; y = Math.random()*height; }
            else { x = width+50; y = Math.random()*height; }
            let type = Math.floor(Math.random()*3), size=30, dur=20, speed=2, color;
            if (type===0) { color='orange'; speed=3; dur=10; }
            else if (type===1) { color='purple'; dur=30; speed=1; }
            else { color='pink'; dur=15; speed=2; }
            enemies.push(new Enemy(x, y, size, color, dur, speed, type));
        }

        function spawnMidBoss() {
            enemies.push(new Enemy(width/2, -100, 50, 'darkred', 50, 1.5, 0, true));
        }

        function spawnBoss() {
            enemies.push(new Enemy(width/2, -200, 80, 'black', 100, 1, 0, true));
        }

        function spawnItem() {
            const x = Math.random()*width, y = Math.random()*height;
            items.push(new Item(x, y));
        }

        function drawController() {
            // 移動ジョイスティック
            ctx.save();
            ctx.translate(width/4, height-150);
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath(); ctx.arc(0, 0, 50, 0, Math.PI*2); ctx.fill();
            if (moveTouch.active) {
                const dx = moveTouch.x - width/4, dy = moveTouch.y - (height-150);
                const dist = Math.min(50, Math.sqrt(dx*dx + dy*dy));
                const angle = Math.atan2(dy, dx);
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(Math.cos(angle)*dist, Math.sin(angle)*dist, 20, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.restore();
            // 回転スライダー
            ctx.save();
            ctx.translate(width*3/4, height-150);
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath(); ctx.arc(0, 0, 50, 0, Math.PI*2); ctx.fill();
            if (rotTouch.active) {
                const rx = rotTouch.x - (width*3/4), ry = rotTouch.y - (height-150);
                const dist = Math.min(50, Math.sqrt(rx*rx + ry*ry));
                const angle = Math.atan2(ry, rx);
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(Math.cos(angle)*dist, Math.sin(angle)*dist, 20, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.restore();
        }

        function startGame() {
            params = {
                difficulty: +document.getElementById('difficulty').value,
                playerSpeed: +document.getElementById('playerSpeed').value,
                initialLife: +document.getElementById('initialLife').value,
                enemySpawn: +document.getElementById('enemySpawn').value,
                itemDur: +document.getElementById('itemDur').value,
                enemyDurMul: +document.getElementById('enemyDurMul').value,
                rotSpeed: +document.getElementById('rotSpeed').value,
                attackPower: +document.getElementById('attackPower').value,
                bgmVol: +document.getElementById('bgmVol').value,
                scoreMul: +document.getElementById('scoreMul').value,
                joySens: +document.getElementById('joySens').value
            };
            document.getElementById('title').style.display = 'none';
            document.getElementById('guide').style.display = 'block';
            player = new Player();
            bgm = playBGM(params.bgmVol);
            gameLoop();
        }

        let lastTime = 0;
        function gameLoop(time) {
            if (gameOver || cleared) {
                bgm.stop();
                ctx.fillStyle = 'white';
                ctx.font = '40px Arial';
                ctx.fillText(gameOver ? 'Game Over' : 'Clear!', width/2 - 100, height/2);
                ctx.fillText(`Score: ${score}`, width/2 - 100, height/2 + 50);
                return;
            }
            requestAnimationFrame(gameLoop);
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = 'rgba(0,0,50,0.5)';
            ctx.fillRect(0,0,width,height);

            player.update();
            player.draw();
            player.attackEnemies();

            enemies.forEach(e => { e.update(); e.draw(); });
            items.forEach(i => { i.update(); i.draw(); });

            drawController();

            if (wave === 0 && enemies.length < params.enemySpawn) spawnEnemy();
            if (wave === 0 && enemies.length === 0 && Math.random() < 0.01 * params.difficulty) {
                wave = 1; spawnMidBoss();
            }
            if (wave === 1 && enemies.length === 0) {
                wave = 2; spawnBoss();
            }
            if (wave === 2 && enemies.length === 0) cleared = true;

            if (Math.random() < 0.005) spawnItem();

            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText(`Life: ${Math.ceil(player.dur/10)}`, 10, 30);
            ctx.fillText(`Score: ${score}`, 10, 60);
        }

        // タッチコントロール
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const touches = e.changedTouches;
            for (let t of touches) {
                if (t.clientX < width/2 && !moveTouch.active) {
                    moveTouch = { id: t.identifier, x: t.clientX, y: t.clientY, active: true };
                } else if (t.clientX >= width/2 && !rotTouch.active) {
                    rotTouch = { id: t.identifier, x: t.clientX, y: t.clientY, active: true };
                }
            }
        });
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const touches = e.changedTouches;
            for (let t of touches) {
                if (t.identifier === moveTouch.id) {
                    moveTouch.x = t.clientX;
                    moveTouch.y = t.clientY;
                } else if (t.identifier === rotTouch.id) {
                    rotTouch.x = t.clientX;
                    rotTouch.y = t.clientY;
                }
            }
        });
        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            const touches = e.changedTouches;
            for (let t of touches) {
                if (t.identifier === moveTouch.id) moveTouch = { id: null, x: 0, y: 0, active: false };
                if (t.identifier === rotTouch.id) rotTouch = { id: null, x: 0, y: 0, active: false };
            }
        });

        // マウス対応（デバッグ用）
        let mouseMove = false, mouseRot = false;
        canvas.addEventListener('mousedown', e => {
            if (e.clientX < width/2) {
                moveTouch = { x: e.clientX, y: e.clientY, active: true };
                mouseMove = true;
            } else {
                rotTouch = { x: e.clientX, y: e.clientY, active: true };
                mouseRot = true;
            }
        });
        canvas.addEventListener('mousemove', e => {
            if (mouseMove) moveTouch = { x: e.clientX, y: e.clientY, active: true };
            if (mouseRot) rotTouch = { x: e.clientX, y: e.clientY, active: true };
        });
        canvas.addEventListener('mouseup', () => {
            moveTouch = { x: 0, y: 0, active: false };
            rotTouch = { x: 0, y: 0, active: false };
            mouseMove = false;
            mouseRot = false;
        });
    </script>
</body>
</html>
